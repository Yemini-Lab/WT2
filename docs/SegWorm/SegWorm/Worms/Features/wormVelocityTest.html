<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of wormVelocityTest</title>
  <meta name="keywords" content="wormVelocityTest">
  <meta name="description" content="SEGWORMVIDEOFRAMES Segment the worm in a set of video frames and organize">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- # SegWorm --><!-- # Worms --><!-- menu.html Features -->
<h1>wormVelocityTest
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>SEGWORMVIDEOFRAMES Segment the worm in a set of video frames and organize</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [velocities centroidVelocities] =wormVelocityTest(wormFile, indices, use, type, scales, isSparse, verbose) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">SEGWORMVIDEOFRAMES Segment the worm in a set of video frames and organize
   the information in a structure.

   [WORMS IMGS OIMGS] = SEGWORMVIDEOFRAMES(VIDEOFILE, FRAME, VERBOSE)

   Inputs:
       infoFile     - the XML file with the experiment information
       logFile      - the CSV file with the stage locations
       diffFile     - the MAT file with the video differentiation
       videoFile    - the name of the video to segment
       vignetteFile - an optional file with the video vignette correction
       startFrameI  - the starting frame of the video sequence to segment
       endFrameI    - the ending frame of the video sequence to segment
       samples      - the number of samples to use in order to normalize
                      the worms (see normWorms)
       use          - if not empty, for each frame, is it usable?
                      The 'use' vector allows one to test replacement
                      algorithms (e.g., interpolation, nearest neighbor,
                      etc.), in differentiation, by comparing the results
                      from real data with tests where elements of this
                      data have been removed by being declared unusable.
                      Note: stage movements and failed segmentation are
                      ALWAYS treated as unusable.
       type         - the type of algorithm to use when replacing unusable
                      data samples (e.g., due to stage movements or failed
                      segmentation). Differentiation is expressed as:

                      dX/dT = -(X1 - X2)/(T1 - T2)

                      type is a 1 or 2 letter string indicating which
                      method to use when replacing an unusable X1 and/or
                      X2. If type is 2 characters long:

                      type(1) = X1
                      type(2) = X2

                      Otherwise, type(1) is used for both X1 and X2. The
                      methods are as follows:

                      i = linearly interpolate unusable data
                          (type(2) is ignored)
                      e = exact match, if data is unusable, the result is NaN
                      b = backwards nearest neighbor
                      f = forwards nearest neighbor
                      n = nearest neighbor

                      Note: the nearest-neighbor type algorithms adjust
                      the time accordingly. If there is no nearest
                      neighbor, differentiation results in NaN.
       scales       - a vector of the scales (in seconds) to use for
                      spacing X1 from X2
       isSparse     - is the differentiation sparse? for each scale,
                      sparse differentiation only calculates the data
                      differences at multiples of that scale
       verbose      - verbose mode shows the results in figures

   Output:
       velocities         - a cell array of the velocities at each scale
       centroidVelocities - a cell array of the centroid velocities at
                            each scale. The centroid is calculated from
                            the worm's contour.

   See also MULTISCALEDIFF, NORMWORMS, SEGWORMVIDEOFRAMES</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../SegWorm/Util/multiScaleDiff.html" class="code" title="function [diffData usedFramesI] = multiScaleDiff(data, use, startI,endI, rate, type, scales, isSparse, isAtT1)">multiScaleDiff</a>	MULTISCALEDIFF Differentiate data at multiple scales.</li><li><a href="../../../SegWorm/Worms/Orientation/headTailMovementConfidence.html" class="code" title="function [headOrthoConfidence tailOrthoConfidenceheadParaConfidence tailParaConfidenceheadMagConfidence tailMagConfidence] =headTailMovementConfidence(worm1, worm2, varargin)">headTailMovementConfidence</a>	HEADTAILMOVEMENTCONFIDENCE How much confidence do we have in the head and</li><li><a href="../../../SegWorm/Worms/Orientation/orientWorm.html" class="code" title="function [worm2 confidence flippedConfidence] =orientWorm(worm1, worm2, samples, varargin)">orientWorm</a>	ORIENTWORM Orient worm2 to match worm1's orientation (by setting</li><li><a href="../../../SegWorm/Worms/Segmentation/segWorm.html" class="code" title="function worm = segWorm(img, frame, isNormalized, verbose, varargin)">segWorm</a>	SEGWORM Segment the worm in an image and organize the information in a</li><li><a href="../../../SegWorm/Worms/StageMovement/findStageMovement.html" class="code" title="function [frames movesI locations] =findStageMovement(infoFile, logFile, diffFile, verbose, varargin)">findStageMovement</a>	FINDSTAGEMOVEMENT Find stage movements in a worm experiment.</li><li><a href="../../../SegWorm/Worms/StageMovement/readPixels2Microns.html" class="code" title="function [pixel2MicronScale rotation] = readPixels2Microns(infoFile)">readPixels2Microns</a>	READPIXELS2MICRONS Read the experiment information file and compute the</li><li><a href="../../../SegWorm/Worms/Util/normWorms.html" class="code" title="function [vulvaContours nonVulvaContours skeletons angles inOutToucheslengths widths headAreas tailAreas vulvaAreas nonVulvaAreas isNormed] =normWorms(worms, samples, moves, origins, pixel2MicronScale,rotation, verbose)">normWorms</a>	NORMWORMS Normalize the worms' information to a standard, compact set.</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [velocities centroidVelocities] = </a><span class="keyword">...</span>
0002     wormVelocityTest(wormFile, indices, use, type, scales, isSparse, verbose)
0003 <span class="comment">%SEGWORMVIDEOFRAMES Segment the worm in a set of video frames and organize</span>
0004 <span class="comment">%   the information in a structure.</span>
0005 <span class="comment">%</span>
0006 <span class="comment">%   [WORMS IMGS OIMGS] = SEGWORMVIDEOFRAMES(VIDEOFILE, FRAME, VERBOSE)</span>
0007 <span class="comment">%</span>
0008 <span class="comment">%   Inputs:</span>
0009 <span class="comment">%       infoFile     - the XML file with the experiment information</span>
0010 <span class="comment">%       logFile      - the CSV file with the stage locations</span>
0011 <span class="comment">%       diffFile     - the MAT file with the video differentiation</span>
0012 <span class="comment">%       videoFile    - the name of the video to segment</span>
0013 <span class="comment">%       vignetteFile - an optional file with the video vignette correction</span>
0014 <span class="comment">%       startFrameI  - the starting frame of the video sequence to segment</span>
0015 <span class="comment">%       endFrameI    - the ending frame of the video sequence to segment</span>
0016 <span class="comment">%       samples      - the number of samples to use in order to normalize</span>
0017 <span class="comment">%                      the worms (see normWorms)</span>
0018 <span class="comment">%       use          - if not empty, for each frame, is it usable?</span>
0019 <span class="comment">%                      The 'use' vector allows one to test replacement</span>
0020 <span class="comment">%                      algorithms (e.g., interpolation, nearest neighbor,</span>
0021 <span class="comment">%                      etc.), in differentiation, by comparing the results</span>
0022 <span class="comment">%                      from real data with tests where elements of this</span>
0023 <span class="comment">%                      data have been removed by being declared unusable.</span>
0024 <span class="comment">%                      Note: stage movements and failed segmentation are</span>
0025 <span class="comment">%                      ALWAYS treated as unusable.</span>
0026 <span class="comment">%       type         - the type of algorithm to use when replacing unusable</span>
0027 <span class="comment">%                      data samples (e.g., due to stage movements or failed</span>
0028 <span class="comment">%                      segmentation). Differentiation is expressed as:</span>
0029 <span class="comment">%</span>
0030 <span class="comment">%                      dX/dT = -(X1 - X2)/(T1 - T2)</span>
0031 <span class="comment">%</span>
0032 <span class="comment">%                      type is a 1 or 2 letter string indicating which</span>
0033 <span class="comment">%                      method to use when replacing an unusable X1 and/or</span>
0034 <span class="comment">%                      X2. If type is 2 characters long:</span>
0035 <span class="comment">%</span>
0036 <span class="comment">%                      type(1) = X1</span>
0037 <span class="comment">%                      type(2) = X2</span>
0038 <span class="comment">%</span>
0039 <span class="comment">%                      Otherwise, type(1) is used for both X1 and X2. The</span>
0040 <span class="comment">%                      methods are as follows:</span>
0041 <span class="comment">%</span>
0042 <span class="comment">%                      i = linearly interpolate unusable data</span>
0043 <span class="comment">%                          (type(2) is ignored)</span>
0044 <span class="comment">%                      e = exact match, if data is unusable, the result is NaN</span>
0045 <span class="comment">%                      b = backwards nearest neighbor</span>
0046 <span class="comment">%                      f = forwards nearest neighbor</span>
0047 <span class="comment">%                      n = nearest neighbor</span>
0048 <span class="comment">%</span>
0049 <span class="comment">%                      Note: the nearest-neighbor type algorithms adjust</span>
0050 <span class="comment">%                      the time accordingly. If there is no nearest</span>
0051 <span class="comment">%                      neighbor, differentiation results in NaN.</span>
0052 <span class="comment">%       scales       - a vector of the scales (in seconds) to use for</span>
0053 <span class="comment">%                      spacing X1 from X2</span>
0054 <span class="comment">%       isSparse     - is the differentiation sparse? for each scale,</span>
0055 <span class="comment">%                      sparse differentiation only calculates the data</span>
0056 <span class="comment">%                      differences at multiples of that scale</span>
0057 <span class="comment">%       verbose      - verbose mode shows the results in figures</span>
0058 <span class="comment">%</span>
0059 <span class="comment">%   Output:</span>
0060 <span class="comment">%       velocities         - a cell array of the velocities at each scale</span>
0061 <span class="comment">%       centroidVelocities - a cell array of the centroid velocities at</span>
0062 <span class="comment">%                            each scale. The centroid is calculated from</span>
0063 <span class="comment">%                            the worm's contour.</span>
0064 <span class="comment">%</span>
0065 <span class="comment">%   See also MULTISCALEDIFF, NORMWORMS, SEGWORMVIDEOFRAMES</span>
0066 
0067 <span class="comment">% Read the info to convert onscreen pixels to real-world microns.</span>
0068 [pixel2MicronScale rotation] = <a href="../../../SegWorm/Worms/StageMovement/readPixels2Microns.html" class="code" title="function [pixel2MicronScale rotation] = readPixels2Microns(infoFile)">readPixels2Microns</a>(infoFile);
0069 
0070 <span class="comment">% Find the stage movements.</span>
0071 [moveFrames moves origins] = <a href="../../../SegWorm/Worms/StageMovement/findStageMovement.html" class="code" title="function [frames movesI locations] =findStageMovement(infoFile, logFile, diffFile, verbose, varargin)">findStageMovement</a>(infoFile, logFile, <span class="keyword">...</span>
0072     diffFile, 0);
0073 
0074 <span class="comment">% Get the vignette.</span>
0075 vImg = 0;
0076 <span class="keyword">if</span> exist(vignetteFile, <span class="string">'file'</span>)
0077     fid = fopen(vignetteFile, <span class="string">'r'</span>);
0078     vImg = fread(fid, [640 480],<span class="string">'int32=&gt;int8'</span>, 0, <span class="string">'b'</span>)';
0079     fclose(fid);
0080 <span class="keyword">end</span>
0081 
0082 <span class="comment">% Open the video.</span>
0083 vr = videoReader(videoFile, <span class="string">'plugin'</span>, <span class="string">'DirectShow'</span>);
0084 
0085 <span class="comment">% Get the frames/second.</span>
0086 fps = get(vr, <span class="string">'fps'</span>);
0087 
0088 <span class="comment">% Segment the video frames.</span>
0089 frames = startFrameI:endFrameI;
0090 <span class="keyword">if</span> isempty(use) <span class="comment">% can we use every frame?</span>
0091     use = true(length(frames), 1);
0092 <span class="keyword">end</span>
0093 worms = cell(length(frames),1);
0094 prevFrame = NaN;
0095 <span class="keyword">for</span> i = 1:length(frames)
0096     
0097     <span class="comment">% Skip over stage movement.</span>
0098     <span class="keyword">if</span> moveFrames(frames(i) + 1)
0099         <span class="keyword">if</span> frames(i) - prevFrame == 1
0100             
0101             <span class="comment">% Is the next frame not a stage movement?</span>
0102             <span class="keyword">if</span> i &lt; length(frames) &amp;&amp; ~moveFrames(frames(i + 1) + 1) &amp;&amp; <span class="keyword">...</span>
0103                     (frames(i + 1) - frames(i)) == 1 &amp;&amp; next(vr)
0104                 
0105                 <span class="comment">% Segment the next frame's worm.</span>
0106                 img2 = rgb2gray(getframe(vr));
0107                 img2 = uint8(single(img2) - single(vImg));
0108                 worm2 = <a href="../../../SegWorm/Worms/Segmentation/segWorm.html" class="code" title="function worm = segWorm(img, frame, isNormalized, verbose, varargin)">segWorm</a>(img2, frames(i) + 1, 1, false);
0109             <span class="keyword">end</span>
0110             
0111             <span class="comment">% Advance.</span>
0112             prevFrame = frames(i);
0113         <span class="keyword">end</span>
0114         
0115         <span class="comment">% Skip to the next frame.</span>
0116         <span class="keyword">continue</span>;
0117     <span class="keyword">end</span>
0118     
0119     <span class="comment">% Use the next video frame.</span>
0120     <span class="keyword">if</span> frames(i) - prevFrame == 1
0121         worms{i} = worm2;
0122 
0123     <span class="comment">% Get the new video frame.</span>
0124     <span class="keyword">else</span>
0125         seek(vr, frames(i));
0126         
0127         <span class="comment">% Convert the frame to grayscale.</span>
0128         img = rgb2gray(getframe(vr));
0129 
0130         <span class="comment">% Correct the vignette.</span>
0131         <span class="keyword">if</span> ~isempty(vImg)
0132             img = uint8(single(img) - single(vImg));
0133         <span class="keyword">end</span>
0134         
0135         <span class="comment">% Segment the worm.</span>
0136         worms{i} = <a href="../../../SegWorm/Worms/Segmentation/segWorm.html" class="code" title="function worm = segWorm(img, frame, isNormalized, verbose, varargin)">segWorm</a>(img, frames(i), 1, false);
0137         
0138         <span class="comment">% The worm is unusable.</span>
0139         <span class="keyword">if</span> isempty(worms{i})
0140             use(i) = false;
0141         <span class="keyword">end</span>
0142         
0143         <span class="comment">% Show the frame information.</span>
0144         timestamp = get(vr, <span class="string">'timeStamp'</span>);
0145         hours = floor(timestamp / 3600);
0146         minutes = floor((timestamp - hours * 60) / 60);
0147         seconds = (timestamp - hours * 3600 - minutes * 60);
0148         disp([<span class="string">'Worm '</span> num2str(frames(i)) <span class="string">'at approximate frame = '</span> <span class="keyword">...</span>
0149             num2str(get(vr, <span class="string">'approxFrameNum'</span>)) <span class="string">', real frame = '</span>  <span class="keyword">...</span>
0150             num2str(timestamp * get(vr, <span class="string">'fps'</span>)) <span class="string">', timestamp = '</span> <span class="keyword">...</span>
0151             num2str(hours) <span class="string">':'</span> num2str(minutes, <span class="string">'%02.0f'</span>) <span class="string">':'</span> <span class="keyword">...</span>
0152             num2str(seconds, <span class="string">'%02.3f'</span>)]);
0153     <span class="keyword">end</span>
0154     
0155     <span class="comment">% Advance.</span>
0156     prevFrame = frames(i);
0157     
0158     <span class="comment">% Compute the proximity and head/tail movement confidence.</span>
0159     <span class="keyword">if</span> next(vr)
0160         
0161         <span class="comment">% Get the next video frame and convert it to grayscale.</span>
0162         img2 = rgb2gray(getframe(vr));
0163         img2 = uint8(single(img2) - single(vImg));
0164         
0165         <span class="comment">% Did the worm in the next frame segment?</span>
0166         worm2 = <a href="../../../SegWorm/Worms/Segmentation/segWorm.html" class="code" title="function worm = segWorm(img, frame, isNormalized, verbose, varargin)">segWorm</a>(img2, frames(i) + 1, 1, 0);
0167         <span class="keyword">if</span> ~isempty(worm2)
0168             
0169             <span class="comment">% Orient the worm and compute the confidence.</span>
0170             samples = [1:3 5:7] / 8;
0171             [worm2 confidence flippedConfidence] = <span class="keyword">...</span>
0172                 <a href="../../../SegWorm/Worms/Orientation/orientWorm.html" class="code" title="function [worm2 confidence flippedConfidence] =orientWorm(worm1, worm2, samples, varargin)">orientWorm</a>(worms{i}, worm2, samples);
0173             [hConfidence tConfidence] = <span class="keyword">...</span>
0174                 <a href="../../../SegWorm/Worms/Orientation/headTailMovementConfidence.html" class="code" title="function [headOrthoConfidence tailOrthoConfidenceheadParaConfidence tailParaConfidenceheadMagConfidence tailMagConfidence] =headTailMovementConfidence(worm1, worm2, varargin)">headTailMovementConfidence</a>(worms{i}, worm2);
0175             
0176             <span class="comment">% Show the proximity and movement confidence.</span>
0177             <span class="keyword">if</span> verbose
0178                 disp([<span class="string">'Proximal orientation confidence:   '</span> <span class="keyword">...</span>
0179                     <span class="string">' confidence = '</span> num2str(confidence) <span class="keyword">...</span>
0180                     <span class="string">' flipped confidence = '</span> num2str(flippedConfidence)]);
0181                 disp([<span class="string">'Head/tail movement confidence: '</span> <span class="keyword">...</span>
0182                     <span class="string">' head confidence = '</span> num2str(hConfidence) <span class="keyword">...</span>
0183                     <span class="string">' tail confidence = '</span> num2str(tConfidence)]);
0184             <span class="keyword">end</span>
0185         <span class="keyword">end</span>
0186     <span class="keyword">end</span>
0187 <span class="keyword">end</span>
0188 
0189 <span class="comment">% Clean up.</span>
0190 close(vr);
0191 
0192 <span class="comment">% Normalize the worms.</span>
0193 [vulvaContours nonVulvaContours skeletons angles inOutTouches <span class="keyword">...</span>
0194     lengths widths headAreas tailAreas vulvaAreas nonVulvaAreas] = <span class="keyword">...</span>
0195     <a href="../../../SegWorm/Worms/Util/normWorms.html" class="code" title="function [vulvaContours nonVulvaContours skeletons angles inOutToucheslengths widths headAreas tailAreas vulvaAreas nonVulvaAreas isNormed] =normWorms(worms, samples, moves, origins, pixel2MicronScale,rotation, verbose)">normWorms</a>(worms, samples, moves, origins, framesStart - 1, <span class="keyword">...</span>
0196     pixel2MicronScale, rotation, false);
0197 
0198 <span class="comment">% Organize the normalized worm data.</span>
0199 data{1} = squeeze(skeletons(:,1,:));
0200 data{2} = squeeze(skeletons(:,2,:));
0201 data{3} = mean([squeeze(vulvaContours(:,1,:)); <span class="keyword">...</span>
0202     squeeze(nonVulvaContours(:,1,:))], 1);
0203 data{4} = mean([squeeze(vulvaContours(:,1,:)); <span class="keyword">...</span>
0204     squeeze(nonVulvaContours(:,1,:))], 1);
0205 <span class="keyword">if</span> verbose
0206     data{5} = angles;
0207     data{6} = lengths;
0208     data{7} = widths;
0209     data{8} = headAreas;
0210     data{9} = tailAreas;
0211     data{10} = vulvaAreas;
0212     data{11} = nonVulvaAreas;
0213 <span class="keyword">end</span>
0214 
0215 <span class="comment">% Pre-allocate memory.</span>
0216 velocities = cell(length(scales), 1);
0217 centroidVelocities = cell(length(scales), 1);
0218 
0219 <span class="comment">% Differentiate the normalized worm data.</span>
0220 diffData = <a href="../../../SegWorm/Util/multiScaleDiff.html" class="code" title="function [diffData usedFramesI] = multiScaleDiff(data, use, startI,endI, rate, type, scales, isSparse, isAtT1)">multiScaleDiff</a>(data, use, 1 / fps, type, <span class="keyword">...</span>
0221     round(scales / fps), isSparse);
0222 <span class="keyword">for</span> i = 1:length(scales)
0223     velocities{i} = sqrt(diffData{1}{i} .^ 2 + diffData{2}{i} .^ 2);
0224     centroidVelocities{i} = sqrt(diffData{3}{i} .^ 2 + diffData{4}{i} .^ 2);
0225 <span class="keyword">end</span>
0226 
0227 <span class="comment">% Show the results in a figure.</span>
0228 <span class="keyword">if</span> verbose
0229 <span class="keyword">end</span>
0230 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Tue 25-Jun-2013 14:47:30 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>